// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import { ModuleBase } from "common/Lib.sol";

import { ISharePriceOracle } from "../interfaces/ISharePriceOracle.sol";
import { FixedPointMathLib } from "solady/utils/FixedPointMathLib.sol";
import { VaultData, VaultLib } from "types/Lib.sol";

/// @title MetaVaultReader
/// @notice Module for reading vault data and calculating returns
/// @dev Provides view functions to get detailed vault information and return metrics
contract MetaVaultReader is ModuleBase {
    using VaultLib for VaultData;
    using FixedPointMathLib for uint256;

    /// @notice Detailed data structure for a vault
    /// @dev Contains key vault parameters and current state
    struct VaultDetailedData {
        /// @dev The ID of the chain where the vault is deployed
        uint32 chainId;
        /// @dev The superform ID of the vault in the Superform protocol
        uint256 superformId;
        /// @dev The oracle that provides the share price for the vault
        ISharePriceOracle oracle;
        /// @dev The number of decimals used in the ERC4626 shares
        uint8 decimals;
        /// @dev The total assets invested in the vault
        uint128 totalDebt;
        /// @dev The address of the vault
        address vaultAddress;
        /// @dev Owned vault shares
        uint256 sharesBalance;
        /// @dev Share price of the vault
        uint256 sharePrice;
        /// @dev Total assets managed by vault
        uint256 totalAssets;
    }

    /// @notice Gets detailed data for a specific vault
    /// @param superformId The ID of the vault to query
    /// @return VaultDetailedData struct containing vault details
    function getVaultDetailedData(uint256 superformId) public view returns (VaultDetailedData memory) {
        VaultData memory vault = vaults[superformId];
        uint256 sharesBalance = _sharesBalance(vault);
        uint256 totalAssets = vault.convertToAssets(sharesBalance, asset(), true);
        uint256 sharePrice = vault.sharePrice(asset());
        return VaultDetailedData(
            vault.chainId,
            vault.superformId,
            vault.oracle,
            vault.decimals,
            vault.totalDebt,
            vault.vaultAddress,
            sharesBalance,
            sharePrice,
            totalAssets
        );
    }

    /// @notice Gets detailed data for all vaults in both withdrawal queues
    /// @return Array of VaultDetailedData structs containing details for all vaults
    function getAllVaultsDetailedData() public view returns (VaultDetailedData[] memory) {
        uint256 localCount;
        uint256 xChainCount;

        // Count non-empty vaults in both queues
        for (uint256 i = 0; i < WITHDRAWAL_QUEUE_SIZE; i++) {
            if (vaults[localWithdrawalQueue[i]].vaultAddress != address(0)) localCount++;
            if (vaults[xChainWithdrawalQueue[i]].vaultAddress != address(0)) xChainCount++;
        }

        VaultDetailedData[] memory allVaultData = new VaultDetailedData[](localCount + xChainCount);
        uint256 currentIndex;

        // Add local withdrawal queue vaults
        for (uint256 i = 0; i < localCount; i++) {
            allVaultData[currentIndex] = getVaultDetailedData(localWithdrawalQueue[i]);
            currentIndex++;
        }

        // Add cross-chain withdrawal queue vaults
        for (uint256 i = 0; i < xChainCount; i++) {
            allVaultData[currentIndex] = getVaultDetailedData(xChainWithdrawalQueue[i]);
            currentIndex++;
        }

        return allVaultData;
    }

    /// @notice Data structure for vault return metrics
    /// @dev Contains total, hurdle and excess returns
    struct VaultReturnsData {
        /// @dev Total return generated by the vault
        uint256 totalReturn;
        /// @dev Minimum return required before performance fees
        uint256 hurdleReturn;
        /// @dev Returns above the hurdle rate
        uint256 excessReturn;
    }

    /// @notice Calculates return metrics for the metavault
    /// @return VaultReturnsData struct containing return metrics
    /// @dev Calculates total return, hurdle return and excess return based on asset value changes
    function getLastEpochVaultReturns() public view returns (VaultReturnsData memory) {
        uint256 currentSharePrice = sharePrice();
        uint256 lastSharePrice = sharePriceWaterMark;
        uint256 duration = block.timestamp - lastFeesCharged;

        uint256 currentTotalAssets = totalAssets();
        uint256 lastTotalAssets = totalSupply().fullMulDiv(lastSharePrice, 10 ** decimals());

        // Calculate returns relative to hurdle rate
        uint256 hurdleReturn = (lastTotalAssets * hurdleRate()).fullMulDiv(duration, SECS_PER_YEAR) / MAX_BPS;

        int256 assetsDelta = int256(currentTotalAssets) - int256(lastTotalAssets);
        uint256 totalReturn = assetsDelta > 0 ? uint256(assetsDelta) : 0;
        uint256 excessReturn = 0;

        // Only calculate excess return if total return exceeds hurdle return and price is above watermark
        if (totalReturn > hurdleReturn && currentSharePrice > sharePriceWaterMark) {
            excessReturn = totalReturn - hurdleReturn;
        }

        return VaultReturnsData(totalReturn, hurdleReturn, excessReturn);
    }

    /// @notice Calculates the total returns per share since inception
    /// @return The difference between current share price and initial share price (1e18)
    /// @dev Returns can be negative if share price is below initial price
    function totalReturnsPerShare() public view returns (int256) {
        return int256(sharePrice()) - int256(10 ** decimals());
    }

    /// @notice Returns the function selectors that this module exposes
    /// @return selectors Array of function selectors
    function selectors() external pure returns (bytes4[] memory) {
        bytes4[] memory _selectors = new bytes4[](4);
        _selectors[0] = this.getVaultDetailedData.selector;
        _selectors[1] = this.getAllVaultsDetailedData.selector;
        _selectors[2] = this.getLastEpochVaultReturns.selector;
        _selectors[3] = this.totalReturnsPerShare.selector;
        return _selectors;
    }
}
